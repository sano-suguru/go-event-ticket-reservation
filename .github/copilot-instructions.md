# Go イベントチケット予約システム - AI エージェント向けガイドライン

本プロジェクトは、楽観的ロック、分散ロック、冪等性などの高度なバックエンド技術を実装した、高並行性イベントチケット予約システムです。

## 最初に必ず読むこと

**調査や実装を開始する前に、必ず `README.md` を読んでください。** README には以下の重要な情報が含まれています：

- プロジェクトの背景と目的
- 詳細なアーキテクチャ設計とその理由
- データベース設計（テーブル定義、インデックス）
- API 設計（エンドポイント一覧）
- 実装フェーズと優先順位
- コード例とベストプラクティス

## プロジェクト概要・アーキテクチャ

- **アーキテクチャ**: Clean Architecture（単方向依存: API -> Application -> Domain <- Infrastructure）
- **言語**: Go（最新安定版）
- **フレームワーク**: Echo（Web フレームワーク）
- **データベース**: PostgreSQL（メイン）、Redis（キャッシュ・分散ロック）
- **ORM/クエリ**: `sqlx`を使用（重量級 ORM は使用しない）
- **インフラ**: ローカル開発は Docker Compose、本番想定は AWS CDK

## 主要な実装パターン

### 1. 並行処理制御

- **楽観的ロック**: `seats`や`events`の更新時は必ず`version`カラムを使用する
  - パターン: `UPDATE table SET ..., version = version + 1 WHERE id = $1 AND version = $2`
  - 更新行数が 0 の場合は`ErrOptimisticLockConflict`を返す
- **分散ロック**: 高トラフィック時の座席予約など、クリティカルセクションには Redis を使用
  - TTL 付きの`SetNX`を使用する

### 2. トランザクション管理

- トランザクションは**アプリケーション層**（Service）で管理する（Domain や Repository では管理しない）
- トランザクション操作には`*sqlx.Tx`を使用する
- トランザクション開始直後に`defer tx.Rollback()`を呼び出すこと

### 3. 冪等性

- 予約作成時は`idempotency_key`を使用して冪等性チェックを実装する
- 処理前に既存キーの存在確認を行う

### 4. エラーハンドリング・ログ

- 構造化ログには`uber-go/zap`を使用する
- エラーはコンテキストを付与してラップする: `fmt.Errorf("予約作成に失敗: %w", err)`
- カスタムエラーは Domain 層で定義する（例: `ErrSeatAlreadyReserved`、`ErrNotFound`）

## ディレクトリ構成

- `cmd/api/`: メインエントリーポイント
- `internal/domain/`: エンティティ、リポジトリインターフェース、ドメインサービス（純粋な Go、外部依存なし）
- `internal/application/`: ユースケース、トランザクション境界
- `internal/infrastructure/`: DB 実装、Redis アダプター、外部 API
- `internal/api/`: ハンドラー（Echo）、ミドルウェア、DTO
- `db/migrations/`: SQL マイグレーションファイル（`golang-migrate`）

## テストガイドライン

- すべてのテストで`testify`（assert、require、mock）を使用する
- **単体テスト**: Domain と Application 層にフォーカスし、リポジトリはモックを使用
- **統合テスト**: Repository 層のテストには実際の DB/Redis インスタンス（Docker 経由）を使用
- 複数シナリオをカバーするために**テーブル駆動テスト**を推奨

## AI との開発方針：TDD を活用する

本プロジェクトでは **TDD（テスト駆動開発）** を基本とする。AI エージェントは以下のサイクルを守ること：

### TDD サイクル（Red → Green → Refactor）

1. **Red**: テストを 1 つ書いて実行し、失敗することを確認する（実装前なので失敗する）
2. **Green**: テストを通す最小限のコードを実装する
3. **Refactor**: テストが通る状態を維持しながらコードを改善する
4. 1 に戻り、次のテストケースへ

### 使い分けの指針

| 状況                     | アプローチ          | 例                                            |
| ------------------------ | ------------------- | --------------------------------------------- |
| **複雑・不確実性が高い** | TDD（1 テストずつ） | 楽観的ロック、分散ロック、予約フロー          |
| **仕様が明確・シンプル** | テスト一括作成      | バリデーション、日付フォーマット、単純な CRUD |

### 重要なルール

- **テストを書いてから実装する**。実装を先に書かない
- **小さく始める**。最初から完璧な設計を目指さず、テストを通しながら設計を育てる
- **AI の暴走を防ぐガードレール**として、テストを活用する。テストが通らない変更は許可しない
- 複雑なロジック（並行処理制御、トランザクション境界）は必ず TDD で進める

## 開発ワークフロー

- **Makefile**: 一般的なタスクには`make`コマンドを使用（`make run`、`make test`、`make migrate-up`）
- **API 仕様**: ハンドラーに OpenAPI/Swagger アノテーションを記述して API を定義
- **マイグレーション**: スキーマ変更時は必ず新しいマイグレーションファイルを作成（`make migrate-create`）

## 固有の規約

- **Context**: I/O を行う関数には必ず第一引数として`context.Context`を渡す
- **設定**: 環境変数から設定を読み込む（`internal/config`を使用）
- **SQL**: PostgreSQL 用のプレースホルダー（`$1`、`$2`）または`sqlx`の名前付きクエリで生 SQL を記述する。動的な SQL 文字列の構築は避ける
